var documenterSearchIndex = {"docs":
[{"location":"man/","page":"Manual","title":"Manual","text":"Documentation for QECC.","category":"page"},{"location":"man/","page":"Manual","title":"Manual","text":"","category":"page"},{"location":"man/#QECC.CSS","page":"Manual","title":"QECC.CSS","text":"An arbitrary CSS error correcting code defined by its X and Z checks.\n\n\n\n\n\n","category":"type"},{"location":"man/#QECC.Cleve8","page":"Manual","title":"QECC.Cleve8","text":"A pedagogical example of a quantum error correcting [8,3] code used in (Cleve and Gottesman, 1997).\n\n\n\n\n\n","category":"type"},{"location":"man/#QECC.Surface","page":"Manual","title":"QECC.Surface","text":"The planar surface code refers to the code (Kitaev, 2003) in a 2D lattice with open boundaries.\n\nIllustration of a 3×2 surface code, where qubits are located on the edges:\n\n|---1--(Z)--2---|---3---|\n|  (X)  7       8       o\n|---4---|---5---|---6---|\n|       o       o       o\n|       |       |       |\n\nThe surface code has open boundary conditions, unlike the toric code. To this end, we remove qubits (denoted by \"o\") and parity checks on the right and bottom sides.\n\nMore information can be seen in (Fowler et al., 2012).\n\n\n\n\n\n","category":"type"},{"location":"man/#QECC.Toric","page":"Manual","title":"QECC.Toric","text":"The Toric code (Kitaev, 2003).\n\nIllustration of a 2x2 toric code, where qubits are located on the edges:\n\n|--1-(Z)-2--|\n| (X) 5     6\n|--3--|--4--|\n|     7     8\n|     |     |\n\nIt is important to note that the toric code has periodic boundary conditions, which means that the top and bottom sides are essentially glued together, as are the left and right sides.\n\n\n\n\n\n","category":"type"},{"location":"man/#QECC.code_n-Tuple{QECC.AbstractQECC}","page":"Manual","title":"QECC.code_n","text":"The number of physical qubits in a code.\n\n\n\n\n\n","category":"method"},{"location":"man/#QECC.code_s-Tuple{QECC.AbstractECC}","page":"Manual","title":"QECC.code_s","text":"The number of stabilizer checks in a code. They might not be all linearly independent, thus code_s >= code_n-code_k. For the number of linearly independent checks you can use LinearAlgebra.rank.\n\n\n\n\n\n","category":"method"},{"location":"man/#QECC.distance","page":"Manual","title":"QECC.distance","text":"The distance of a code.\n\n\n\n\n\n","category":"function"},{"location":"man/#QECC.hgp-Tuple{Any, Any}","page":"Manual","title":"QECC.hgp","text":"Hypergraph product of two classical codes.\n\n\n\n\n\n","category":"method"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Cleve, R. and Gottesman, D. (1997). Efficient computations of encodings for quantum error correction. Physical Review A 56, 76.\n\n\n\nFowler, A. G.; Mariantoni, M.; Martinis, J. M. and Cleland, A. N. (2012). Surface codes: Towards practical large-scale quantum computation. Physical Review A 86, 032324.\n\n\n\nKitaev, A. (2003). Fault-tolerant quantum computation by anyons. Annals of Physics 303, 2–30.\n\n\n\n","category":"page"},{"location":"#QECC","page":"Home","title":"QECC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quantum error correction codes.","category":"page"}]
}
